---
title: 3.6 Digital Controller Representation and Difference Equation Solutions
description: Move from continuous controller equations to implementable discrete-time updates.
---

# 3.6 Digital Controller Representation and Difference Equation Solutions

## Learning Outcomes

1. Represent digital controllers in $z$-domain.
2. Derive and interpret controller difference equations.
3. Solve first/second-order difference equations for response behavior.

## Glossary

| Term | Meaning |
| --- | --- |
| $z$-domain | Transform domain for discrete-time systems. |
| Difference equation | Recursive update equation used in digital controller code. |
| Homogeneous response | Natural response from internal dynamics/initial conditions. |
| Particular response | Forced response due to external input sequence. |
| Sample index $k$ | Discrete time step number. |

## Explanation

This chapter connects math and implementation.
If you can write difference equations correctly, you can implement controllers on real hardware.

## Why this topic matters

Real controllers run on microcontrollers/CPUs.
That means your algorithm updates at sample instants, not continuously.

## Generic digital controller form

<EquationHelp hint="In implementation, this equation turns into code that uses stored past errors and past control outputs.">

$$
U(z)=C(z)E(z)
$$

</EquationHelp>

If

$$
C(z)=\frac{b_0+b_1z^{-1}+\dots+b_mz^{-m}}{1+a_1z^{-1}+\dots+a_nz^{-n}}
$$

then time-domain update is:

$$
u[k]=-a_1u[k-1]-\dots-a_nu[k-n]+b_0e[k]+\dots+b_me[k-m]
$$

## Difference equation solution view

Response = homogeneous part + particular part.

- Homogeneous part: natural modes from characteristic roots.
- Particular part: forced response due to input.

Stability requires homogeneous part to decay.

## Plain-English coding interpretation

Difference equations are control code in equation form.
Each sample, your controller:

1. reads current error,
2. uses stored past errors/outputs,
3. computes new command,
4. stores values for next sample.

So this topic is the bridge between math and firmware implementation.

## Common Mistakes

- Wrong sign on feedback terms in code.
- Forgetting to initialize memory terms.
- Using inconsistent sample time between model and software loop.
- Numeric overflow/precision issues in fixed-point targets.

## Worked Example

Given:

$$
u[k]=0.6u[k-1]+0.5e[k]-0.2e[k-1]
$$

Interpretation:

- first-order memory in output ($u[k-1]$),
- one-step memory in error ($e[k-1]$),
- implementable with two stored variables per cycle.

## Detailed Review

Confirm you can:

1. Move between $C(z)$ form and difference-equation form.
2. Explain why recursive controllers need state memory in code.
3. Identify stability risk from recursive coefficients.

## Assignments

Given

$$
u[k]=0.6u[k-1]+0.5e[k]-0.2e[k-1]
$$

1. Identify controller order.
2. Explain what memory terms are required in code.

## Citations

- [R6](/syllabus/references#r6)
- [R2](/syllabus/references#r2)
- [R8](/syllabus/references#r8)
